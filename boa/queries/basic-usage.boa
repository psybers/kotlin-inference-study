o: output sum[project: string][revision: string][outtime: time][file: string][location: string][isval: bool][isinferred: bool] of int; # Count

{@escape@}

location: stack of string;

visit(input, visitor {
    before node: Revision -> {
        # Output zeroes as necessary
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["return_val"][false][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["return_val"][false][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["module"][true][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["module"][true][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["module"][false][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["module"][false][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["body"][true][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["body"][true][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["body"][false][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["body"][false][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["loop_variable"][true][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["loop_variable"][true][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["loop_variable"][false][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["loop_variable"][false][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["lambda_arg"][true][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["lambda_arg"][true][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["lambda_arg"][false][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["lambda_arg"][false][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["module"][true][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["module"][true][true] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["module"][false][false] << 0;
        o[input.id][current(Revision).id][current(Revision).commit_date]["DUMMYDUMMYDUMMY.kt"]["module"][false][true] << 0;
    }
    before node: ChangedFile -> {
        if (! match(node.kind, "SOURCE_KOTLIN_1_"))
            stop;
    }
    before node: Namespace -> push(location, "module");
    after node: Namespace -> pop(location);
    before node: Declaration -> {
        foreach(i: int; def(node.methods[i]))
            visit(node.methods[i]);
        foreach(i: int; def(node.nested_declarations[i]))
            visit(node.nested_declarations[i]);
        stop;
    }
    before node: Method -> {
        file := current(ChangedFile).name;
        if (def(node.expression)) {
            isinferred := ! def(node.return_type);
            o[input.id][current(Revision).id][current(Revision).commit_date][escape(file)]["return_val"][false][isinferred] << 1;
        }
        push(location, "body");
        if (def(node.expression)) visit(node.expression);
        foreach(i: int; def(node.statements[i]))
            visit(node.statements[i]);
        pop(location);
        stop;
    }
    before node: Statement -> {
        if (node.kind == StatementKind.FOR) {
            push(location, "loop_variable");
            if (def(node.variable_declaration))
                visit(node.variable_declaration);
            pop(location);
            foreach(i: int; def(node.expressions[i]))
                visit(node.expressions[i]);
            foreach(i: int; def(node.statements[i]))
                visit(node.statements[i]);
            stop;
        }
    }
    before node: Expression -> {
        if (node.kind == ExpressionKind.LAMBDA) {
            push(location, "lambda_arg");
            foreach(i: int; def(node.variable_decls[i])) {
                visit(node.variable_decls[i]);
            }
            pop(location);
        }
        push(location, "body");
        foreach(i: int; def(node.expressions[i]))
            visit(node.expressions[i]);
        foreach(i: int; def(node.statements[i]))
            visit(node.statements[i]);
        pop(location);
        stop;
    }
    before node: Variable -> {
        file := current(ChangedFile).name;
        place := peek(location);
        isval := false;
        exists(i: int; (def(node.modifiers[i]) && node.modifiers[i].kind == ModifierKind.FINAL))
            isval = true;
        isinferred := !def(node.variable_type);
        o[input.id][current(Revision).id][current(Revision).commit_date][escape(file)][place][isval][isinferred] << 1;
    }
});
