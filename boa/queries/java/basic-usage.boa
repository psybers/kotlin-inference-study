o: output sum[project: string][file: string]{@time-out@}[location: string][isval: bool][isinferred: bool] of int; # Count

{@escape@}

location: stack of string;

visit(input, visitor {
    before node: CodeRepository -> {
        # Output zeroes as necessary
        kinds := {
            "body",
            "lambda_arg"
        };
        foreach (i: int; def(kinds[i])) {
            o[input.id]["DUMMYDUMMYDUMMY.java"]{@time-part@}[kinds[i]][true][false] << 0;
            o[input.id]["DUMMYDUMMYDUMMY.java"]{@time-part@}[kinds[i]][true][true] << 0;
        }
        snapshot := getsnapshot(node, "SOURCE_JAVA_JLS");
        foreach (i: int; def(snapshot[i]))
            visit(snapshot[i]);
        stop;
    }
    before node: Declaration -> {
        foreach (i: int; def(node.methods[i]))
            visit(node.methods[i]);
        foreach (i: int; def(node.nested_declarations[i]))
            visit(node.nested_declarations[i]);
        stop;
    }
    before node: Method -> {
        file := current(ChangedFile).name;
        push(location, "body");
        foreach (i: int; def(node.statements[i]))
            visit(node.statements[i]);
        pop(location);
        stop;
    }
    before node: Expression -> {
        if (node.kind == ExpressionKind.LAMBDA) {
            push(location, "lambda_arg");
            foreach (i: int; def(node.variable_decls[i]))
                visit(node.variable_decls[i]);
            pop(location);
        }
        push(location, "body");
        foreach (i: int; def(node.expressions[i]))
            visit(node.expressions[i]);
        foreach (i: int; def(node.statements[i]))
            visit(node.statements[i]);
        pop(location);
        stop;
    }
    before node: Variable -> {
        file := current(ChangedFile).name;
        place := peek(location);
        isinferred := node.variable_type.name == "var";
        o[input.id][escape(file)]{@time-part@}[place][has_modifier(node, ModifierKind.FINAL)][isinferred] << 1;
    }
});