m: output collection[project: string][is_inferred: bool] of string;

project_methods: set of string;
imported_classes: set of string;
project_classes: set of string;

{@kotlin-default-imports@}

{@project-filter@}
{
    visit(input, visitor {
        before node: CodeRepository -> {
            snapshot := getsnapshot(node, "SOURCE_KOTLIN_1_");
            foreach (i: int; def(snapshot[i]))
                visit(snapshot[i]);
            stop;
        }

        before node: Declaration -> add(project_classes, node.name);
        before node: Method -> add(project_methods, node.name);
    });
    visit(input, visitor {
        before node: CodeRepository -> {
            snapshot := getsnapshot(node, "SOURCE_KOTLIN_1_");
            foreach (i: int; def(snapshot[i]))
                visit(snapshot[i]);
            stop;
        }

        before node: Namespace -> {
            foreach(i: int; def(node.imports[i])) {
                parts := split(node.imports[i], `\.`);
                last_item := parts[len(parts) - 1];
                if (last_item != "*")
                    add(imported_classes, last_item);
            }
        }

        after node: Namespace -> {
            clear(imported_classes);
        }

        before node: Declaration -> {
            foreach (i: int; def(node.methods[i]))
                visit(node.methods[i]);
            foreach (i: int; def(node.fields[i]))
                visit(node.fields[i]);
            foreach (i: int; def(node.nested_declarations[i]))
                visit(node.nested_declarations[i]);
            stop;
        }

        before node: Variable -> {
            if (!has_modifier(node, ModifierKind.IMPLICIT)) {
                isinferred := !def(node.variable_type);
                rhskind := "??";
                if (def(node.initializer))
                    rhskind = string(node.initializer.kind);
                if (rhskind == "METHODCALL") {
                    method_name := node.initializer.method;
                    if (contains(project_methods, method_name) || contains(default_functions, method_name))
                        m[input.id][isinferred] << "METHODCALL";
                    else if (contains(project_classes, method_name) || contains(imported_classes, method_name) || contains(default_imports, method_name))
                        m[input.id][isinferred] << "NEW";
                    else if (match(`^[A-Z]`, method_name))
                        m[input.id][isinferred] << "NEW";
                    else
                        m[input.id][isinferred] << "METHODCALL";
                } else {
                    m[input.id][isinferred] << rhskind;
                }
            }
        }
    });
}
