{@locations-enum@}

type ChangeType = enum {
    FILE_DELETED = "FILE_DELETED",
    ITEM_DISAPPEARED = "ITEM_DISAPPEARED",
    STATE_SWITCHED = "STATE_SWITCHED"
};

o: output collection[project: string][file: string][item: string][location: Location][startinferred: bool][changekind: ChangeType][changeobserved: bool] of int; # length_of_time

{@escape@}

type Status = {
 name: string,
 file: string,
 is_inferred: bool,
 creation_time: bool,
 location: Location
};

status: map[string] of Status;
file_items: map[string] of set of string;
has_changed: set of string;

location: stack of Location;
name_parts: stack of string;
order_stack: stack of int;

get_loc_name := function (file: string): string {
    return format("%s#%s#%s", file, join(".", name_parts), peek(location));
}

seen_items: set of string;

head_time: time;

{@project-filter@}
{
    visit(input, visitor {
            before repository: CodeRepository -> {
            headrev := getrevision(repository, repository.head);
                head_time = headrev.commit_date;
            head_revision := repository.head;
                push(order_stack, head_revision);

                visit(headrev);
                stop;
            }
            before rev: Revision -> {
                if (len(rev.parents) > 0) {
                next_commit := rev.parents[0];
                    push(order_stack, next_commit);
                    visit(getrevision(current(CodeRepository), next_commit));
                }
                stop;
            }
        });
    while (len(order_stack) > 0) {
        current_commit_number := pop(order_stack);
        visit(input, visitor {
                before repository: CodeRepository -> {
                    visit(getrevision(repository, current_commit_number));
                    stop;
                }
                before node: Namespace -> {
                    push(name_parts, node.name);
                    push(location, Location.MODULE);
                }
                after node: Namespace -> {
                    pop(name_parts);
                    pop(location);
                }
                before node: ChangedFile -> {
                    if (!iskind("SOURCE_KOTLIN_1_", node.kind))
                        stop;
                    if (node.change == ChangeKind.DELETED) {
                        empty_string_set: set of string;
                        locs := values(lookup(file_items, node.name, empty_string_set));
                        foreach (i: int; def(locs[i])) {
                            loc := locs[i];
                            item_status := status[loc];
                            o[input.id][item_status.file][item_status.name][item_status.location][item_status.is_inferred][ChangeType.FILE_DELETED][false] << current(Revision).commit_date - item_status.creation_time;
                            add(has_changed, loc);
                            remove(status, loc);
                        }
                        remove(file_items, node.name);
                        stop;
                    }
                }
                after node: ChangedFile -> {
                    empty_string_set: set of string;
                    locs := values(difference(lookup(file_items, node.name, empty_string_set), seen_items));
                    foreach (i: int; def(locs[i])) {
                        loc := locs[i];
                        item_status := status[loc];
                        o[input.id][item_status.file][item_status.name][item_status.location][item_status.is_inferred][ChangeType.ITEM_DISAPPEARED][false] << current(Revision).commit_date - item_status.creation_time;
                        add(has_changed, loc);
                        remove(status, loc);
                        remove(file_items[node.name], loc);
                    }
                    clear(seen_items);
                }
                before node: Declaration -> push(name_parts, node.name);
                after  node: Declaration -> pop(name_parts);
                before node: Method -> {
                    push(name_parts, node.name);
                    file := current(ChangedFile).name;
                    name := join(".", name_parts);
                    if(def(node.expression)) {
                        push(location, Location.RET_VAL);
                        loc := get_loc_name(file);
                        isinferred := !def(node.return_type);
                        add(seen_items, loc);
                        if (!haskey(file_items, file)) {
                            empty_set: set of string;
                            file_items[file] = empty_set;
                        }
                        if (!contains(file_items[file], loc) && !contains(has_changed, loc)) {
                            add(file_items[file], loc);
                            item_status: Status = { name, escape(file), inferred, current(Revision).commit_date, peek(location)};
                            status[loc] = item_status;
                        } else if (!contains(has_changed[loc]) && isinferred != status[loc].is_inferred) {
                            item_status := status[loc];
                            o[input.id][item_status.file][item_status.name][item_status.location][item_status.is_inferred][ChangeType.STATE_SWITCHED][true] << current(Revision).commit_date - item_status.creation_time;
                            add(has_changed, loc);
                            remove(file_items[file], loc);
                            remove(status, loc);
                        }
                        pop(location);
                    }
                    push(location, BODY);
                    if (def(node.expression))
                        visit(node.expression);
                    foreach (i: int; def(node.statements[i]))
                        visit(node.statements[i]);
                    pop(location);
                    stop;
                }
                after node: Method -> pop(name_parts);
                before node: Statement -> {
                    if (node.kind == StatementKind.FOR) {
                        push(location, Location.LOOP_VAR);
                        if (def(node.variable_declaration))
                            visit(node.variable_declaration);
                        pop(location);
                        foreach (i: int; def(node.expressions[i]))
                            visit(node.expressions[i]);
                        foreach (i: int; def(node.statements[i]))
                            visit(node.statements[i]);
                        stop;
                    }
                }
                before node: Expression -> {
                    if (node.kind == ExpressionKind.LAMBDA) {
                        push(location, Location.LAMBDA_ARG);
                        foreach (i: int; def(node.variable_decls[i]))
                            visit(node.variable_decls[i]);
                        pop(location);
                    }
                    foreach (i: int; def(node.expressions[i]))
                        visit(node.expressions[i]);
                    foreach (i: int; def(node.statements[i]))
                        visit(node.statements[i]);
                    stop;
                }
                before node: Variable -> {
                    push(name_parts, node.name);
                    file := current(ChangedFile).name;
                    place := peek(location);
                    loc := get_loc_name(file);
                    add(seen_items, loc);
                    name := join(".", name_parts);
                    isinferred := !def(node.variable_type);
                    if (!haskey(file_items, file)) {
                        empty_set: set of string;
                        file_items[file] = empty_set;
                    }
                    if (!contains(file_items[file], loc) && !contains(has_changed, loc)) {
                        add(file_items[file], loc);
                        item_status: Status = { name, escape(file), inferred, current(Revision).commit_date, peek(location)};
                        status[loc] = item_status;
                    } else if (!contains(has_changed[loc]) && isinferred != status[loc].is_inferred) {
                        item_status := status[loc];
                        o[input.id][item_status.file][item_status.name][item_status.location][item_status.is_inferred][ChangeType.STATE_SWITCHED][true] << current(Revision).commit_date - item_status.creation_time;
                        add(has_changed, loc);
                        remove(file_items[file], loc);
                        remove(status, loc);
                    }
                }
                after node: Variable -> pop(name_parts);
            });
    }
}
