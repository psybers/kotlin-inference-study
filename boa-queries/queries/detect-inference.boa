o: output sum[project: string][file: string][location: string][isinferred: bool] of int; # Count

escape := function(s: string): string {
    return strreplace(s, "\\n", "\\\\n", true);
};

location: stack of string;

visit(input, visitor {
    before node: CodeRepository -> {
        snapshot := getsnapshot(node, "SOURCE_KOTLIN_1_");
        foreach (i: int; def(snapshot[i]))
            visit(snapshot[i]);
        stop;
    }
    before node: Namespace -> push(location, "module");
    after node: Namespace -> pop(location);
    before node: Declaration -> {
        foreach(i: int; def(node.methods[i]))
            visit(node.methods[i]);
        foreach(i: int; def(node.nested_declarations[i]))
            visit(node.nested_declarations[i]);
        stop;
    }
    before node: Method -> {
        file := current(ChangedFile).name;
	if (def(node.return_type))
            o[input.id][file]["return"][false] << 1;
	else
	    o[input.id][file]["return"][true] << 1;
        push(location, "body");
        if (def(node.expression)) visit(node.expression);
        foreach(i: int; def(node.statements[i]))
            visit(node.statements[i]);
        pop(location);
        stop;
    }
    before node: Statement -> {
        if (node.kind == StatementKind.FOREACH) {
            push(location, "loop_variable");
            foreach(i: int; def(node.variable_declarations[i]))
	        visit(node.variable_declarations[i]);
            pop(location);
            foreach(i: int; def(node.expressions[i]))
                visit(node.expressions[i]);
            foreach(i: int; def(node.statements[i]))
                visit(node.statements[i]);
            stop;
        }
    }
    before node: Expression -> {
        if (node.kind == ExpressionKind.LAMBDA) {
            push(location, "lambda_arg");
            foreach(i: int; def(node.variable_decls[i])) {
                visit(node.variable_decls[i]);
            }
            pop(location);
        }
        push(location, "body");
        foreach(i: int; def(node.expressions[i]))
            visit(node.expressions[i]);
        foreach(i: int; def(node.statements[i]))
            visit(node.statements[i]);
        pop(location);
        stop;
    }
    before node: Variable -> {
        file := current(ChangedFile).name;
        place := peek(location);
	if (def(node.variable_type))
            o[input.id][file][place][false] << 1;
	else
	    o[input.id][file][place][true] << 1;
    }
});